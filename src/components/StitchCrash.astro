---
---

<!-- Static noise canvas (TV static) -->
<canvas
  id="crash-noise"
  class="fixed inset-0 z-[198] pointer-events-none"
  style="display: none; opacity: 0.15; mix-blend-mode: overlay;"
></canvas>

<!-- Red danger flash -->
<div
  id="crash-red-flash"
  class="fixed inset-0 z-[198] pointer-events-none"
  style="display: none; background: radial-gradient(ellipse at center, #ff0040, #ff0000 60%, transparent 100%); opacity: 0;"
></div>

<!-- Color inversion overlay -->
<div
  id="crash-invert"
  class="fixed inset-0 z-[198] pointer-events-none"
  style="display: none; background: white; mix-blend-mode: difference; opacity: 0;"
></div>

<!-- Scanline overlay (hidden by default) -->
<div
  id="crash-scanline"
  class="fixed inset-0 z-[199] pointer-events-none"
  style="display: none;"
>
  <div style="
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 229, 255, 0.06) 2px,
      rgba(0, 229, 255, 0.06) 4px
    );
    pointer-events: none;
  "></div>
  <div id="crash-scanbar" style="
    position: absolute;
    left: 0;
    right: 0;
    height: 8px;
    background: linear-gradient(90deg, transparent, rgba(255, 0, 64, 0.6), rgba(0, 229, 255, 0.6), transparent);
    box-shadow: 0 0 30px rgba(255, 0, 64, 0.4), 0 0 30px rgba(0, 229, 255, 0.4);
    pointer-events: none;
  "></div>
</div>

<!-- Full-screen crash overlay -->
<div
  id="crash-overlay"
  class="fixed inset-0 z-[200] pointer-events-none flex flex-col items-center justify-end"
  style="display: none;"
>
  <!-- Dark vignette background -->
  <div class="absolute inset-0 bg-gradient-to-t from-bg-dark via-bg-dark/80 to-transparent" style="opacity: 0; transition: opacity 1s ease;" id="crash-bg"></div>

  <!-- Stitch + message -->
  <div id="crash-message" class="relative z-10 text-center mb-[25vh]" style="opacity: 0; transform: scale(0.8); transition: opacity 0.6s ease 0.3s, transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s;">
    <img
      src="/stitch-crash.webp"
      alt="Stitch"
      class="w-36 h-36 md:w-48 md:h-48 object-contain mx-auto drop-shadow-2xl"
      draggable="false"
    />
    <div class="mt-4 space-y-2">
      <div class="font-mono text-lg md:text-xl text-primary font-bold tracking-wide">
        SYSTEM CRASH
      </div>
      <div class="font-mono text-sm text-gray-400">
        <span class="text-red-400">●</span> docker-compose down <span class="text-syntax-comment"># oops</span>
      </div>
      <div class="font-mono text-xs text-gray-500 mt-4 animate-pulse">
        move mouse to reboot...
      </div>
    </div>
  </div>
</div>

<script is:inline>
(function() {
  var IDLE_MS = 1 * 1000;
  var overlay = document.getElementById('crash-overlay');
  var crashBg = document.getElementById('crash-bg');
  var crashMsg = document.getElementById('crash-message');
  var scanlineOverlay = document.getElementById('crash-scanline');
  var scanbar = document.getElementById('crash-scanbar');
  var noiseCanvas = document.getElementById('crash-noise');
  var redFlash = document.getElementById('crash-red-flash');
  var invertOverlay = document.getElementById('crash-invert');
  if (!overlay || !crashBg || !crashMsg) return;

  var leftAt = null;
  var crashed = false;
  var savedElements = [];
  var noiseRAF = null;

  // ── Glitch VFX helpers ──
  var GLITCH_DURATION = 800; // ms — longer, more terrifying

  // TV static noise generator
  function renderNoise() {
    if (!noiseCanvas) return;
    var ctx = noiseCanvas.getContext('2d');
    if (!ctx) return;
    noiseCanvas.width = window.innerWidth / 4; // low-res for perf + gritty look
    noiseCanvas.height = window.innerHeight / 4;
    var w = noiseCanvas.width;
    var h = noiseCanvas.height;
    var imageData = ctx.createImageData(w, h);
    var data = imageData.data;
    for (var i = 0; i < data.length; i += 4) {
      var v = Math.random() * 255;
      data[i] = v;       // R
      data[i+1] = v;     // G
      data[i+2] = v;     // B
      data[i+3] = 255;   // A
    }
    ctx.putImageData(imageData, 0, 0);
    noiseRAF = requestAnimationFrame(renderNoise);
  }

  function startGlitchVFX() {
    var body = document.body;

    // 1. Violent screen shake with skew + rotation
    body.style.animation = 'crashShake ' + GLITCH_DURATION + 'ms ease-in-out, crashFlicker ' + (GLITCH_DURATION * 0.7) + 'ms steps(1)';

    // 2. RGB chromatic aberration on main content
    var main = document.querySelector('main') || body;
    main.style.animation = 'rgbSplit ' + GLITCH_DURATION + 'ms linear, tearSlice ' + (GLITCH_DURATION * 0.6) + 'ms steps(1)';

    // 3. TV static noise
    if (noiseCanvas) {
      noiseCanvas.style.display = 'block';
      renderNoise();
    }

    // 4. Red danger flash
    if (redFlash) {
      redFlash.style.display = 'block';
      redFlash.style.animation = 'redFlash ' + GLITCH_DURATION + 'ms ease-in-out';
    }

    // 5. Color inversion pulse
    if (invertOverlay) {
      invertOverlay.style.display = 'block';
      invertOverlay.style.animation = 'invertPulse ' + (GLITCH_DURATION * 0.5) + 'ms steps(1)';
    }

    // 6. Scanline sweep (3x faster passes)
    if (scanlineOverlay && scanbar) {
      scanlineOverlay.style.display = 'block';
      scanbar.style.animation = 'scanlineSweep ' + (GLITCH_DURATION / 3) + 'ms linear infinite';
    }
  }

  function stopGlitchVFX() {
    var body = document.body;
    body.style.animation = '';
    var main = document.querySelector('main') || body;
    main.style.animation = '';
    main.style.clipPath = '';

    // Stop noise
    if (noiseRAF) { cancelAnimationFrame(noiseRAF); noiseRAF = null; }
    if (noiseCanvas) noiseCanvas.style.display = 'none';

    // Stop red flash
    if (redFlash) { redFlash.style.animation = ''; redFlash.style.display = 'none'; }

    // Stop inversion
    if (invertOverlay) { invertOverlay.style.animation = ''; invertOverlay.style.display = 'none'; }

    // Keep scanlines visible during crash for CRT vibe
    if (scanbar) scanbar.style.animation = '';
  }

  document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      leftAt = Date.now();
    } else if (leftAt) {
      var away = Date.now() - leftAt;
      leftAt = null;
      if (away >= IDLE_MS && !crashed) {
        triggerCrash();
      }
    }
  });

  function triggerCrash() {
    crashed = true;
    savedElements = [];

    // 1. Scroll to top instantly
    window.scrollTo({ top: 0, behavior: 'instant' });

    // Prevent horizontal scroll during crash
    document.body.style.overflowX = 'hidden';

    // ── Phase 1: Glitch VFX ──
    startGlitchVFX();

    // ── Phase 2: After glitch, collapse elements ──
    setTimeout(function() {
      stopGlitchVFX();

      // Grab entire top-level blocks so nothing stays behind
      var selectors = [
        'header',            // IDE tab bar
        '#about',            // entire hero section
        '#experience',       // entire experience section
        '#projects',         // entire projects section
        '#contact',          // entire contact section
        'footer',            // status bar
      ];

      var elements = [];
      selectors.forEach(function(sel) {
        var els = document.querySelectorAll(sel);
        els.forEach(function(el) { elements.push(el); });
      });

      if (elements.length === 0) { crashed = false; return; }

      var viewH = window.innerHeight;
      var viewCenter = viewH * 0.55; // pile center point

      // For each element, calculate how to "fall" it to the pile
      elements.forEach(function(el, i) {
        var rect = el.getBoundingClientRect();
        var elCenter = rect.top + rect.height / 2;

        // How far to move to reach the pile center
        var deltaY = viewCenter - elCenter;

        // Random tilt and horizontal shift for messy pile effect
        var rotate = (Math.random() - 0.5) * 20;
        var shiftX = (Math.random() - 0.5) * 40;
        // Elements further from center get more extreme transforms
        var scaleDown = 0.85 + Math.random() * 0.1;

        savedElements.push({
          el: el,
          origTransform: el.style.transform || '',
          origTransition: el.style.transition || '',
          origZIndex: el.style.zIndex || '',
          origPosition: el.style.position || '',
          origOverflow: el.style.overflow || ''
        });

        // Prepare for animation
        el.style.position = 'relative';
        el.style.zIndex = String(50 - i);
        el.style.overflow = 'hidden';
        el.style.transition = 'none';

        // Apply crash with stagger
        setTimeout(function() {
          el.style.transition = 'transform 0.9s cubic-bezier(0.55, 0, 0.98, 0.54)';
          el.style.transform = 'translateY(' + deltaY + 'px) rotate(' + rotate + 'deg) translateX(' + shiftX + 'px) scale(' + scaleDown + ')';
        }, i * 50 + 50);
      });

      // Hide the corner Stitch debugger during crash
      var stitchCorner = document.getElementById('stitch-debugger');
      if (stitchCorner) stitchCorner.style.display = 'none';

      // Show overlay after elements finish falling
      var fallDuration = elements.length * 50 + 900 + 100;
      setTimeout(function() {
        overlay.style.display = 'flex';
        overlay.style.pointerEvents = 'auto';
        crashBg.style.opacity = '1';
        crashMsg.style.opacity = '1';
        crashMsg.style.transform = 'scale(1)';
        // Hide scanlines when overlay is up
        if (scanlineOverlay) scanlineOverlay.style.display = 'none';
      }, fallDuration);

      // Wait a beat then listen for reboot trigger
      setTimeout(function() {
        document.addEventListener('mousemove', reboot, { once: true });
        document.addEventListener('touchstart', reboot, { once: true });
        document.addEventListener('keydown', reboot, { once: true });
      }, fallDuration + 300);

    }, GLITCH_DURATION);
  }

  function reboot() {
    // Hide overlay
    crashBg.style.opacity = '0';
    crashMsg.style.opacity = '0';
    crashMsg.style.transform = 'scale(0.8)';

    setTimeout(function() {
      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';
      // Restore corner Stitch
      var stitchCorner = document.getElementById('stitch-debugger');
      if (stitchCorner) stitchCorner.style.display = '';
      // Restore horizontal scroll
      document.body.style.overflowX = '';
    }, 600);

    // Spring cards back with stagger
    savedElements.forEach(function(item, i) {
      var el = item.el;
      setTimeout(function() {
        el.style.transition = 'transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1)';
        el.style.transform = item.origTransform || 'none';
      }, i * 40);

      // Cleanup styles after animation
      setTimeout(function() {
        el.style.transition = item.origTransition;
        el.style.transform = item.origTransform;
        el.style.zIndex = item.origZIndex;
        el.style.position = item.origPosition;
        el.style.overflow = item.origOverflow;
      }, i * 40 + 900);
    });

    // Cooldown — allow re-crash after 10 min
    setTimeout(function() {
      crashed = false;
      savedElements = [];
    }, 10 * 60 * 1000);
  }
})();
</script>
